{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "prefixForAllResources": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Prefix for all resources"
      }
    }
  },
  "variables": {
    "uniqueResourceIdentifier": "[substring(uniqueString(resourceGroup().id, parameters('prefixForAllResources')), 0, 4)]",
    "prefixNameClean": "[format('{0}{1}', replace(parameters('prefixForAllResources'), '-', ''), variables('uniqueResourceIdentifier'))]",
    "prefixNameCleanShort": "[if(greater(length(variables('prefixNameClean')), 16), substring(variables('prefixNameClean'), 0, 8), variables('prefixNameClean'))]",
    "createRoleAssignment": true,
    "tenantId": "[subscription().tenantId]",
    "fhirservicename": "[format('{0}/{1}', variables('workspaceName'), variables('fhirName'))]",
    "dicomservicename": "[format('{0}/{1}', variables('workspaceName'), variables('dicomName'))]",
    "loginURL": "[environment().authentication.loginEndpoint]",
    "authority": "[format('{0}{1}', variables('loginURL'), variables('tenantId'))]",
    "audience": "[format('https://{0}-{1}.fhir.azurehealthcareapis.com', variables('workspaceName'), variables('fhirName'))]",
    "storageBlobDataContributorRole": "[format('/subscriptions/{0}/providers/Microsoft.Authorization/roleDefinitions/ba92f5b4-2d11-453d-a403-e96b0029c9fe', subscription().subscriptionId)]",
    "queueDataContRole": "[format('/subscriptions/{0}/providers/Microsoft.Authorization/roleDefinitions/974c5e8b-45b9-4653-ba55-5f855dd0fb88', subscription().subscriptionId)]",
    "subscriptionid": "[subscription().subscriptionId]",
    "resourcegroupname": "[resourceGroup().name]",
    "managedIdentityName": "[format('{0}-{1}', variables('workspaceName'), variables('dicomName'))]",
    "pipelineName": "Copy IDP DICOM Metadata Changes to ADLS Gen2 in Delta Format",
    "location": "[resourceGroup().location]",
    "queueName": "[format('{0}queue', variables('prefixNameCleanShort'))]",
    "storageAccountName": "[format('{0}stdatastore', variables('prefixNameCleanShort'))]",
    "ingestContainerName": "ingest",
    "processedContainerName": "processed",
    "idpDicomContainerName": "idpdicom",
    "eventGridSubscriptionName": "[format('{0}eventgrid', variables('prefixNameCleanShort'))]",
    "workspaceName": "[format('{0}ws', variables('prefixNameCleanShort'))]",
    "fhirName": "[format('{0}fhir', variables('prefixNameCleanShort'))]",
    "dicomName": "[format('{0}dicom', variables('prefixNameCleanShort'))]",
    "storageQueueProcessingAppName": "[format('{0}strgqprocapp', variables('prefixNameCleanShort'))]",
    "storageQProcessingStorageName": "[format('{0}qprocappstrg', variables('prefixNameCleanShort'))]",
    "storageQProcessingPlanName": "[format('{0}strgqprocplan', variables('prefixNameCleanShort'))]",
    "applicationInsightsName": "[format('ai{0}', variables('storageQueueProcessingAppName'))]",
    "dataFactoryName": "[format('{0}healthaiadf', variables('prefixNameCleanShort'))]",
    "RestServicename": "[format('{0}dcmlinkedservice', variables('prefixNameCleanShort'))]",
    "AzureDataLakeStoragename": "[format('{0}dcmonelake', variables('prefixNameCleanShort'))]",
    "keyVaultName": "[format('{0}notebookkv', variables('prefixNameCleanShort'))]",
    "principalType": "ServicePrincipal",
    "packageUri": "https://sthealthai.blob.core.windows.net/publish/StrgQueueProcApp.zip"
  },
  "resources": [
    {
      "type": "Microsoft.Web/sites/config",
      "apiVersion": "2021-03-01",
      "name": "[format('{0}/{1}', variables('storageQueueProcessingAppName'), 'web')]",
      "properties": {
        "ftpsState": "Disabled",
        "minTlsVersion": "1.2"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName'))]"
      ]
    },
    {
      "type": "Microsoft.Web/sites/basicPublishingCredentialsPolicies",
      "apiVersion": "2021-03-01",
      "name": "[format('{0}/{1}', variables('storageQueueProcessingAppName'), 'ftp')]",
      "location": "[variables('location')]",
      "properties": {
        "allow": false
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName'))]"
      ]
    },
    {
      "type": "Microsoft.Web/sites/basicPublishingCredentialsPolicies",
      "apiVersion": "2021-03-01",
      "name": "[format('{0}/{1}', variables('storageQueueProcessingAppName'), 'scm')]",
      "location": "[variables('location')]",
      "properties": {
        "allow": false
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts",
      "apiVersion": "2022-05-01",
      "name": "[variables('storageAccountName')]",
      "location": "[variables('location')]",
      "sku": {
        "name": "Standard_LRS"
      },
      "kind": "StorageV2",
      "properties": {
        "accessTier": "Hot",
        "supportsHttpsTrafficOnly": true,
        "isHnsEnabled": true,
        "minimumTlsVersion": "TLS1_2",
        "allowBlobPublicAccess": false,
        "defaultToOAuthAuthentication": true,
        "encryption": {
          "keySource": "Microsoft.Storage",
          "requireInfrastructureEncryption": true,
          "services": {
            "blob": {
              "enabled": true
            },
            "file": {
              "enabled": true
            },
            "queue": {
              "enabled": true
            }
          }
        }
      }
    },
    {
      "type": "Microsoft.Storage/storageAccounts/blobServices",
      "apiVersion": "2022-05-01",
      "name": "[format('{0}/{1}', variables('storageAccountName'), 'default')]",
      "properties": {
        "deleteRetentionPolicy": {
          "enabled": false,
          "days": 7
        },
        "containerDeleteRetentionPolicy": {
          "enabled": false,
          "days": 7
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/blobServices/containers",
      "apiVersion": "2021-08-01",
      "name": "[format('{0}/{1}/{2}', variables('storageAccountName'), 'default', variables('ingestContainerName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts/blobServices', variables('storageAccountName'), 'default')]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/blobServices/containers",
      "apiVersion": "2023-01-01",
      "name": "[format('{0}/{1}/{2}', variables('storageAccountName'), 'default', variables('processedContainerName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts/blobServices', variables('storageAccountName'), 'default')]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/blobServices/containers",
      "apiVersion": "2023-01-01",
      "name": "[format('{0}/{1}/{2}', variables('storageAccountName'), 'default', variables('idpDicomContainerName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts/blobServices', variables('storageAccountName'), 'default')]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/queueServices/queues",
      "apiVersion": "2021-08-01",
      "name": "[format('{0}/default/{1}', variables('storageAccountName'), variables('queueName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.EventGrid/eventSubscriptions",
      "apiVersion": "2023-06-01-preview",
      "scope": "[format('Microsoft.Storage/storageAccounts/{0}', variables('storageAccountName'))]",
      "name": "[variables('eventGridSubscriptionName')]",
      "properties": {
        "destination": {
          "endpointType": "StorageQueue",
          "properties": {
            "resourceId": "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]",
            "queueName": "[variables('queueName')]",
            "queueMessageTimeToLiveInSeconds": -1
          }
        },
        "filter": {
          "includedEventTypes": [
            "Microsoft.Storage.BlobCreated"
          ],
          "subjectBeginsWith": "[format('/blobServices/default/containers/{0}', variables('ingestContainerName'))]",
          "enableAdvancedFilteringOnArrays": true
        },
        "labels": [],
        "eventDeliverySchema": "EventGridSchema"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "apiVersion": "2023-01-31",
      "name": "[variables('managedIdentityName')]",
      "location": "[variables('location')]"
    },
    {
      "type": "Microsoft.HealthcareApis/workspaces",
      "apiVersion": "2022-06-01",
      "name": "[variables('workspaceName')]",
      "location": "[variables('location')]"
    },
    {
      "type": "Microsoft.HealthcareApis/workspaces/fhirservices",
      "apiVersion": "2022-06-01",
      "name": "[variables('fhirservicename')]",
      "location": "[variables('location')]",
      "kind": "fhir-R4",
      "identity": {
        "type": "SystemAssigned"
      },
      "properties": {
        "authenticationConfiguration": {
          "authority": "[variables('authority')]",
          "audience": "[variables('audience')]",
          "smartProxyEnabled": false
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.HealthcareApis/workspaces', variables('workspaceName'))]"
      ]
    },
    {
      "type": "Microsoft.HealthcareApis/workspaces/dicomservices",
      "apiVersion": "2022-06-01",
      "name": "[variables('dicomservicename')]",
      "location": "[variables('location')]",
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('managedIdentityName')))]": {}
        }
      },
      "properties": {
        "storageConfiguration": {
          "accountName": "[variables('storageAccountName')]",
          "containerName": "[variables('ingestContainerName')]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('managedIdentityName'))]",
        "[resourceId('Microsoft.HealthcareApis/workspaces', variables('workspaceName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults",
      "apiVersion": "2023-07-01",
      "name": "[variables('keyVaultName')]",
      "location": "[variables('location')]",
      "properties": {
        "sku": {
          "family": "A",
          "name": "standard"
        },
        "tenantId": "[subscription().tenantId]",
        "accessPolicies": [],
        "enabledForDeployment": false,
        "enabledForDiskEncryption": false,
        "enabledForTemplateDeployment": false,
        "enableSoftDelete": true,
        "softDeleteRetentionInDays": 90,
        "enableRbacAuthorization": true,
        "provisioningState": "Succeeded",
        "publicNetworkAccess": "Enabled"
      }
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'fhirAuthurl')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'fhirClientId')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'fhirClientSecret')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'fhirUrl')]",
      "properties": {
        "contentType": "text/plain",
        "value": "[format('https://{0}-{1}.fhir.azurehealthcareapis.com', variables('workspaceName'), variables('fhirName'))]",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'aiApiKey')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'aiResourceName')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'aiDeploymentName')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'aiApiVersion')]",
      "properties": {
        "contentType": "text/plain",
        "value": " ",
        "attributes": {
          "enabled": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.Web/sites",
      "apiVersion": "2021-03-01",
      "name": "[variables('storageQueueProcessingAppName')]",
      "kind": "functionapp,linux",
      "location": "[variables('location')]",
      "identity": {
        "type": "SystemAssigned"
      },
      "properties": {
        "enabled": true,
        "clientAffinityEnabled": false,
        "httpsOnly": true,
        "serverFarmId": "[resourceId('Microsoft.Web/serverfarms', variables('storageQProcessingPlanName'))]",
        "siteConfig": {
          "linuxFxVersion": "dotnet-isolated|7.0",
          "use32BitWorkerProcess": false,
          "alwaysOn": true
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/serverfarms', variables('storageQProcessingPlanName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageQProcessingStorageName'))]",
        "[resourceId('Microsoft.Insights/components', variables('applicationInsightsName'))]"
      ]
    },
    {
      "type": "Microsoft.Web/sites/config",
      "apiVersion": "2021-03-01",
      "name": "[format('{0}/{1}', variables('storageQueueProcessingAppName'), 'appsettings')]",
      "properties": {
        "FUNCTIONS_EXTENSION_VERSION": "~4",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated",
        "AzureWebJobsStorage": "[format('DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1};EndpointSuffix=core.windows.net', variables('storageAccountName'), listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName')), '2019-06-01').keys[0].value)]",
        "fhirUri": "[format('https://{0}.fhir.azurehealthcareapis.com', replace(variables('fhirservicename'), '/', '-'))]",
        "DicomUri": "[format('https://{0}.dicom.azurehealthcareapis.com', replace(variables('dicomservicename'), '/', '-'))]",
        "fhirHttpClient": "[format('https://{0}.fhir.azurehealthcareapis.com', replace(variables('fhirservicename'), '/', '-'))]",
        "dicomHttpClient": "[format('https://{0}.dicom.azurehealthcareapis.com/v1', replace(variables('dicomservicename'), '/', '-'))]",
        "dicomResourceUri": "https://dicom.healthcareapis.azure.com",
        "storageAccountName": "[variables('storageAccountName')]",
        "sourceContainerName": "[variables('ingestContainerName')]",
        "processedContainerName": "[variables('processedContainerName')]",
        "queueName": "[variables('queueName')]",
        "storageUri": "[format('https://{0}.blob.core.windows.net/', variables('storageAccountName'))]",
        "AppInsightConnectionString": "[reference(format('microsoft.insights/components/{0}', variables('applicationInsightsName')), '2015-05-01').ConnectionString]",
        "APPINSIGHTS_INSTRUMENTATIONKEY": "[reference(format('microsoft.insights/components/{0}', variables('applicationInsightsName')), '2015-05-01').InstrumentationKey]",
        "WEBSITE_RUN_FROM_PACKAGE": "0",
        "SCM_DO_BUILD_DURING_DEPLOYMENT=true"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Insights/components', variables('applicationInsightsName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageQProcessingStorageName'))]",
        "[resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName'))]"
      ]
    },
    {
      "type": "Microsoft.Web/serverfarms",
      "apiVersion": "2021-03-01",
      "name": "[variables('storageQProcessingPlanName')]",
      "location": "[variables('location')]",
      "kind": "functionapp",
      "sku": {
        "tier": "Standard",
        "name": "S2"
      },
      "properties": {
        "reserved": true
      },
      "metadata": {
        "description": "App Service used to run Azure Function"
      }
    },
    {
      "type": "Microsoft.Insights/components",
      "apiVersion": "2020-02-02-preview",
      "name": "[variables('applicationInsightsName')]",
      "location": "[variables('location')]",
      "kind": "web",
      "properties": {
        "Application_Type": "web"
      },
      "metadata": {
        "description": "Monitoring for Function App"
      }
    },
    {
      "type": "Microsoft.Storage/storageAccounts",
      "apiVersion": "2022-05-01",
      "name": "[variables('storageQProcessingStorageName')]",
      "location": "[variables('location')]",
      "kind": "StorageV2",
      "sku": {
        "name": "Standard_LRS"
      },
      "properties": {
        "supportsHttpsTrafficOnly": true,
        "minimumTlsVersion": "TLS1_2",
        "defaultToOAuthAuthentication": true
      },
      "metadata": {
        "description": "Azure Function required linked storage account"
      }
    },
    {
      "type": "Microsoft.Web/sites/extensions",
      "apiVersion": "2022-03-01",
      "name": "[format('{0}/{1}', variables('storageQueueProcessingAppName'), 'ZipDeploy')]",
      "properties": {
        "packageUri": "[variables('packageUri')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName'))]"
      ]
    },
    {
      "type": "Microsoft.DataFactory/factories",
      "apiVersion": "2018-06-01",
      "name": "[variables('dataFactoryName')]",
      "location": "[variables('location')]",
      "identity": {
        "type": "SystemAssigned"
      }
    },
    {
      "type": "Microsoft.DataFactory/factories/linkedservices",
      "apiVersion": "2018-06-01",
      "name": "[format('{0}/{1}', variables('dataFactoryName'), variables('RestServicename'))]",
      "properties": {
        "annotations": [],
        "type": "RestService",
        "typeProperties": {
          "url": "[format('https://{0}.dicom.azurehealthcareapis.com', variables('managedIdentityName'))]",
          "enableServerCertificateValidation": true,
          "authenticationType": "ManagedServiceIdentity",
          "aadResourceId": "https://dicom.healthcareapis.azure.com"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.DataFactory/factories', variables('dataFactoryName'))]"
      ]
    },
    {
      "type": "Microsoft.DataFactory/factories/linkedservices",
      "apiVersion": "2018-06-01",
      "name": "[format('{0}/{1}', variables('dataFactoryName'), variables('AzureDataLakeStoragename'))]",
      "properties": {
        "annotations": [],
        "type": "AzureBlobFS",
        "typeProperties": {
          "url": "[format('https://{0}.dfs.core.windows.net/', variables('storageAccountName'))]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.DataFactory/factories', variables('dataFactoryName'))]"
      ]
    },
    {
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "name": "[format('{0}/{1}', variables('dataFactoryName'), variables('pipelineName'))]",
      "properties": {
        "activities": [
          {
            "name": "Update Delta Tables",
            "description": "Read the change feed in batches and synchronize any changes with Delta Tables.",
            "type": "Until",
            "dependsOn": [],
            "userProperties": [],
            "typeProperties": {
              "expression": {
                "value": "@not(variables('Continue'))",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Process Batch",
                  "description": "Update the Delta Tables using a page of data from the Change Feed.",
                  "type": "ExecuteDataFlow",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": true,
                    "secureInput": true
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "dataFlow": {
                      "referenceName": "Update IDP DICOM Delta Tables",
                      "type": "DataFlowReference",
                      "parameters": {
                        "Offset": {
                          "value": "@int(variables('CurrentOffset'))",
                          "type": "Expression"
                        },
                        "Limit": {
                          "value": "@pipeline().parameters.BatchSize",
                          "type": "Expression"
                        },
                        "ApiVersion": {
                          "value": "@pipeline().parameters.ApiVersion",
                          "type": "Expression"
                        },
                        "StartTime": {
                          "value": "'@{pipeline().parameters.StartTime}'",
                          "type": "Expression"
                        },
                        "EndTime": {
                          "value": "'@{pipeline().parameters.EndTime}'",
                          "type": "Expression"
                        },
                        "ContainerName": {
                          "value": "'@{pipeline().parameters.ContainerName}'",
                          "type": "Expression"
                        },
                        "InstanceTablePath": {
                          "value": "'@{pipeline().parameters.InstanceTablePath}'",
                          "type": "Expression"
                        },
                        "SeriesTablePath": {
                          "value": "'@{pipeline().parameters.SeriesTablePath}'",
                          "type": "Expression"
                        },
                        "StudyTablePath": {
                          "value": "'@{pipeline().parameters.StudyTablePath}'",
                          "type": "Expression"
                        },
                        "RetentionHours": {
                          "value": "@pipeline().parameters.RetentionHours",
                          "type": "Expression"
                        }
                      },
                      "datasetParameters": {
                        "changeFeed": {},
                        "existingInstances": {},
                        "existingSeries": {},
                        "instanceTable": {},
                        "seriesTable": {},
                        "studyTable": {},
                        "seriesCache": {},
                        "studyCache": {}
                      }
                    },
                    "staging": {},
                    "compute": {
                      "coreCount": 8,
                      "computeType": "General"
                    },
                    "traceLevel": "Fine"
                  }
                },
                {
                  "name": "Determine Continuation",
                  "description": "Check the previous activity for metrics related to the instance table sink to determine whether processing should continue.",
                  "type": "IfCondition",
                  "dependsOn": [
                    {
                      "activity": "Process Batch",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@contains(activity('Process Batch').output.runStatus.metrics, 'instanceTable')",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Complete Processing",
                        "description": "Signal that processing should stop because there are no more changes.",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "variableName": "Continue",
                          "value": {
                            "value": "@bool('false')",
                            "type": "Expression"
                          }
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Check Rows",
                        "description": "Update the continuation variable based on the number of rows processed in the last batch.",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "variableName": "Continue",
                          "value": {
                            "value": "@greater(activity('Process Batch').output.runStatus.metrics.instanceTable.rowsWritten, 0)",
                            "type": "Expression"
                          }
                        }
                      },
                      {
                        "name": "Add Limit to Offset",
                        "description": "Add the limit to the current offset.",
                        "type": "SetVariable",
                        "dependsOn": [
                          {
                            "activity": "Check Rows",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "variableName": "Temp",
                          "value": {
                            "value": "@string(add(int(variables('CurrentOffset')), pipeline().parameters.BatchSize))",
                            "type": "Expression"
                          }
                        }
                      },
                      {
                        "name": "Update Offset",
                        "description": "Update the current offset based on the newly computed value.",
                        "type": "SetVariable",
                        "dependsOn": [
                          {
                            "activity": "Add Limit to Offset",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "variableName": "CurrentOffset",
                          "value": {
                            "value": "@variables('Temp')",
                            "type": "Expression"
                          }
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "Cancel Processing",
                  "description": "Signal that processing should stop because there was a problem processing a batch.",
                  "type": "SetVariable",
                  "dependsOn": [
                    {
                      "activity": "Process Batch",
                      "dependencyConditions": [
                        "Failed"
                      ]
                    }
                  ],
                  "policy": {
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "variableName": "Continue",
                    "value": {
                      "value": "@bool('false')",
                      "type": "Expression"
                    }
                  }
                }
              ],
              "timeout": "0.12:00:00"
            }
          }
        ],
        "policy": {
          "elapsedTimeMetric": {}
        },
        "parameters": {
          "BatchSize": {
            "type": "int",
            "defaultValue": 200
          },
          "ApiVersion": {
            "type": "int",
            "defaultValue": 2
          },
          "StartTime": {
            "type": "string",
            "defaultValue": "0001-01-01T00:00:00Z"
          },
          "EndTime": {
            "type": "string",
            "defaultValue": "9999-12-31T23:59:59Z"
          },
          "ContainerName": {
            "type": "string",
            "defaultValue": "[variables('idpDicomContainerName')]"
          },
          "InstanceTablePath": {
            "type": "string",
            "defaultValue": "instance"
          },
          "SeriesTablePath": {
            "type": "string",
            "defaultValue": "series"
          },
          "StudyTablePath": {
            "type": "string",
            "defaultValue": "study"
          },
          "RetentionHours": {
            "type": "int",
            "defaultValue": 720
          }
        },
        "variables": {
          "CurrentOffset": {
            "type": "String",
            "defaultValue": "0"
          },
          "Temp": {
            "type": "String",
            "defaultValue": "0"
          },
          "Continue": {
            "type": "Boolean",
            "defaultValue": false
          }
        },
        "annotations": []
      },
      "dependsOn": [
        "[resourceId('Microsoft.DataFactory/factories', variables('dataFactoryName'))]",
        "[resourceId('Microsoft.DataFactory/factories/dataflows', variables('dataFactoryName'), 'Update IDP DICOM Delta Tables')]"
      ]
    },
    {
      "type": "Microsoft.DataFactory/factories/triggers",
      "apiVersion": "2018-06-01",
      "name": "[format('{0}/{1}', variables('dataFactoryName'), 'hourlytrigger7')]",
      "properties": {
        "description": "Trigger that runs hourly",
        "annotations": [],
        "runtimeState": "Started",
        "pipeline": {
          "pipelineReference": {
            "referenceName": "[variables('pipelineName')]",
            "type": "PipelineReference"
          },
          "parameters": {
            "StartTime": "@trigger().outputs.windowStartTime",
            "EndTime": "@trigger().outputs.windowEndTime"
          }
        },
        "type": "TumblingWindowTrigger",
        "typeProperties": {
          "frequency": "Minute",
          "interval": 60,
          "startTime": "2023-11-24T13:56:00Z",
          "delay": "00:15:00",
          "maxConcurrency": 1,
          "retryPolicy": {
            "intervalInSeconds": 30
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.DataFactory/factories', variables('dataFactoryName'))]",
        "[resourceId('Microsoft.DataFactory/factories/pipelines', variables('dataFactoryName'), variables('pipelineName'))]"
      ]
    },
    {
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "name": "[format('{0}/{1}', variables('dataFactoryName'), 'Update IDP DICOM Delta Tables')]",
      "properties": {
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[variables('RestServicename')]",
                "type": "LinkedServiceReference"
              },
              "name": "changeFeed",
              "description": "Read changes from the DICOMweb server."
            },
            {
              "linkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              },
              "name": "existingInstances",
              "description": "Read the newly updated SOP Instance Delta Table."
            },
            {
              "linkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              },
              "name": "existingSeries",
              "description": "Read the newly updated Series Delta Table."
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              },
              "name": "instanceTable",
              "description": "Write the changes to the SOP Instance Delta Table.",
              "rejectedDataLinkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "linkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              },
              "name": "seriesTable",
              "description": "Write the changes to the Series Delta Table.",
              "rejectedDataLinkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "linkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              },
              "name": "studyTable",
              "description": "Write the changes to the Study Delta Table.",
              "rejectedDataLinkedService": {
                "referenceName": "[variables('AzureDataLakeStoragename')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "seriesCache",
              "description": "Write modified series identifiers to cache."
            },
            {
              "name": "studyCache",
              "description": "Write modified study identifiers to cache."
            }
          ],
          "transformations": [
            {
              "name": "extracted",
              "description": "Extract DICOM attributes."
            },
            {
              "name": "flattened",
              "description": "Flatten the complex object."
            },
            {
              "name": "instanceSinkUpdates",
              "description": "Update the sink based on the action."
            },
            {
              "name": "aggregatedChanges",
              "description": "Aggregate changes for the same SOP instance within the window."
            },
            {
              "name": "allSeries",
              "description": "Aggregate SOP instance within the same series."
            },
            {
              "name": "allStudies",
              "description": "Aggregate series within the same study."
            },
            {
              "name": "seriesSinkUpdates",
              "description": "Update the sink based on the instance count."
            },
            {
              "name": "studySinkUpdate",
              "description": "Update the sink based on the instance count."
            },
            {
              "name": "seriesChanges",
              "description": "Determine the identifiers for modified series."
            },
            {
              "name": "studyChanges",
              "description": "Determine the identifiers for modified studies."
            },
            {
              "name": "modifiedSeries",
              "description": "Filter out the series which have not been updated."
            },
            {
              "name": "annotatedSeries",
              "description": "Determines whether the series has been modified."
            },
            {
              "name": "annotatedStudies",
              "description": "Determines whether the series has been modified."
            },
            {
              "name": "modifiedStudies",
              "description": "Filter out the studies which have not been updated."
            },
            {
              "name": "upToDate",
              "description": "Filter out the instances that have since been deleted or updated outside of the window."
            }
          ],
          "scriptLines": [
            "parameters{",
            "     Offset as integer (0),",
            "     Limit as integer (200),",
            "     ApiVersion as integer (2),",
            "     StartTime as string ('0001-01-01T00:00:00Z'),",
            "     EndTime as string ('9999-12-31T23:59:59Z'),",
            "[format('     ContainerName as string (''{0}''),', variables('idpDicomContainerName'))]",
            "     InstanceTablePath as string ('instance'),",
            "     SeriesTablePath as string ('series'),",
            "     StudyTablePath as string ('study'),",
            "     RetentionHours as integer (720)",
            "}",
            "source(output(",
            "          body as (action as string, metadata as (undefined as string), partitionName as string, sequence as short, seriesInstanceUid as string, sopInstanceUid as string, state as string, studyInstanceUid as string, timestamp as string, filePath as string),",
            "          headers as [string,string]",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'rest',",
            "     timeout: 30,",
            "     requestInterval: 0,",
            "     entity: (concat('/v', toString($ApiVersion), '/changefeed')),",
            "     queryParameters: ['includeMetadata' -> 'true', 'offset' -> ($Offset), 'limit' -> ($Limit), 'startTime' -> ($StartTime), 'endTime' -> ($EndTime)],",
            "     httpMethod: 'GET',",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'arrayOfDocuments']) ~> changeFeed",
            "source(output(",
            "          partitionName as string,",
            "          studyInstanceUid as string,",
            "          seriesInstanceUid as string,",
            "          sopInstanceUid as string,",
            "          lastModifiedTimestamp as timestamp,",
            "          studyDate as date,",
            "          studyDescription as string,",
            "          issuerOfPatientId as string,",
            "          patientId as string,",
            "          patientName as string,",
            "          modality as string,",
            "          sopClassUid as string,",
            "          filePath as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     ignoreNoFilesFound: true,",
            "     format: 'delta',",
            "     fileSystem: ($ContainerName),",
            "     folderPath: ($InstanceTablePath)) ~> existingInstances",
            "source(output(",
            "          partitionName as string,",
            "          studyInstanceUid as string,",
            "          seriesInstanceUid as string,",
            "          lastModifiedTimestamp as timestamp,",
            "          studyDate as date,",
            "          studyDescription as string,",
            "          issuerOfPatientId as string,",
            "          patientId as string,",
            "          patientName as string,",
            "          modality as string,",
            "          instanceCount as long",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     ignoreNoFilesFound: true,",
            "     format: 'delta',",
            "     fileSystem: ($ContainerName),",
            "     folderPath: ($SeriesTablePath)) ~> existingSeries",
            "flattened derive(timestamp = toTimestamp(substring(timestamp, 1, 23), 'yyyy-MM-dd\\'T\\'HH:mm:ss.SSS', 'UTC'),",
            "          studyDate = toDate(byPath('metadata.{00080020}.Value[1]'), 'yyyyMMdd', 'UTC'),",
            "          studyDescription = toString(byPath('metadata.{00081030}.Value[1]')),",
            "          issuerOfPatientId = toString(byPath('metadata.{00100021}.Value[1]')),",
            "          patientId = toString(byPath('metadata.{00100020}.Value[1]')),",
            "          patientName = toString(byPath('metadata.{00100010}.Value[1].Alphabetic')),",
            "          modality = toString(byPath('metadata.{00080060}.Value[1]')),",
            "          sopClassUid = toString(byPath('metadata.{00080016}.Value[1]')),",
            "          filePath = toString(filePath)) ~> extracted",
            "changeFeed select(mapColumn(",
            "          action = body.action,",
            "          timestamp = body.timestamp,",
            "          partitionName = body.partitionName,",
            "          studyInstanceUid = body.studyInstanceUid,",
            "          seriesInstanceUid = body.seriesInstanceUid,",
            "          sopInstanceUid = body.sopInstanceUid,",
            "          metadata = body.metadata,",
            "          filePath = body.filePath",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> flattened",
            "upToDate alterRow(upsertIf(or(equals(action,'Create'),equals(action,'Update'))),",
            "     deleteIf(equals(action,'Delete'))) ~> instanceSinkUpdates",
            "extracted aggregate(groupBy(partitionName,",
            "          studyInstanceUid,",
            "          seriesInstanceUid,",
            "          sopInstanceUid),",
            "     action = last(action),",
            "          lastModifiedTimestamp = last(timestamp),",
            "          studyDate = last(studyDate),",
            "          studyDescription = last(studyDescription),",
            "          issuerOfPatientId = last(issuerOfPatientId),",
            "          patientId = last(patientId),",
            "          patientName = last(patientName),",
            "          modality = last(modality),",
            "          sopClassUid = last(sopClassUid),",
            "          filePath = last(filePath)) ~> aggregatedChanges",
            "existingInstances aggregate(groupBy(partitionName,",
            "          studyInstanceUid,",
            "          seriesInstanceUid),",
            "     lastModifiedTimestamp = last(lastModifiedTimestamp),",
            "          studyDate = last(studyDate),",
            "          studyDescription = last(studyDescription),",
            "          issuerOfPatientId = last(issuerOfPatientId),",
            "          patientId = last(patientId),",
            "          patientName = last(patientName),",
            "          modality = last(modality),",
            "          instanceCount = count()) ~> allSeries",
            "existingSeries aggregate(groupBy(partitionName,",
            "          studyInstanceUid),",
            "     lastModifiedTimestamp = last(lastModifiedTimestamp),",
            "          studyDate = last(studyDate),",
            "          studyDescription = last(studyDescription),",
            "          issuerOfPatientId = last(issuerOfPatientId),",
            "          patientId = last(patientId),",
            "          patientName = last(patientName),",
            "          instanceCount = sum(instanceCount),",
            "          seriesCount = count()) ~> allStudies",
            "modifiedSeries alterRow(upsertIf(instanceCount>0),",
            "     deleteIf(instanceCount<=0)) ~> seriesSinkUpdates",
            "modifiedStudies alterRow(upsertIf(instanceCount>0),",
            "     deleteIf(instanceCount<=0)) ~> studySinkUpdate",
            "upToDate aggregate(groupBy(partitionName,",
            "          studyInstanceUid,",
            "          seriesInstanceUid),",
            "     instanceDifference = sum(iif(equals(action, 'Create'), 1, iif(equals(action, 'Delete'), -1, 0)))) ~> seriesChanges",
            "seriesChanges aggregate(groupBy(partitionName,",
            "          studyInstanceUid),",
            "     instanceDifference = sum(instanceDifference)) ~> studyChanges",
            "annotatedSeries filter(hasChange) ~> modifiedSeries",
            "allSeries derive(hasChange = not(isNull(seriesCache#lookup(partitionName, studyInstanceUid, seriesInstanceUid)))) ~> annotatedSeries",
            "allStudies derive(hasChange = not(isNull(studyCache#lookup(partitionName, studyInstanceUid)))) ~> annotatedStudies",
            "annotatedStudies filter(hasChange) ~> modifiedStudies",
            "aggregatedChanges filter(or(not(isNull(filePath)), equals(action, 'Delete'))) ~> upToDate",
            "instanceSinkUpdates sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delta',",
            "     fileSystem: ($ContainerName),",
            "     folderPath: ($InstanceTablePath),",
            "     mergeSchema: true,",
            "     autoCompact: true,",
            "     optimizedWrite: false,",
            "     vacuum: ($RetentionHours),",
            "     deletable: true,",
            "     insertable: false,",
            "     updateable: false,",
            "     upsertable: true,",
            "     keys:['partitionName','studyInstanceUid','seriesInstanceUid','sopInstanceUid'],",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     saveOrder: 1,",
            "     mapColumn(",
            "          partitionName,",
            "          studyInstanceUid,",
            "          seriesInstanceUid,",
            "          sopInstanceUid,",
            "          lastModifiedTimestamp,",
            "          studyDate,",
            "          studyDescription,",
            "          issuerOfPatientId,",
            "          patientId,",
            "          patientName,",
            "          modality,",
            "          sopClassUid,",
            "          filePath",
            "     ),",
            "     partitionBy('key',",
            "          0,",
            "          partitionName",
            "     )) ~> instanceTable",
            "seriesSinkUpdates sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delta',",
            "     fileSystem: ($ContainerName),",
            "     folderPath: ($SeriesTablePath),",
            "     mergeSchema: true,",
            "     autoCompact: true,",
            "     optimizedWrite: false,",
            "     vacuum: ($RetentionHours),",
            "     deletable: true,",
            "     insertable: false,",
            "     updateable: false,",
            "     upsertable: true,",
            "     keys:['partitionName','studyInstanceUid','seriesInstanceUid'],",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     saveOrder: 2,",
            "     mapColumn(",
            "          partitionName,",
            "          studyInstanceUid,",
            "          seriesInstanceUid,",
            "          lastModifiedTimestamp,",
            "          studyDate,",
            "          studyDescription,",
            "          issuerOfPatientId,",
            "          patientId,",
            "          patientName,",
            "          modality,",
            "          instanceCount",
            "     ),",
            "     partitionBy('key',",
            "          0,",
            "          partitionName",
            "     )) ~> seriesTable",
            "studySinkUpdate sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delta',",
            "     fileSystem: ($ContainerName),",
            "     folderPath: ($StudyTablePath),",
            "     mergeSchema: true,",
            "     autoCompact: true,",
            "     optimizedWrite: false,",
            "     vacuum: ($RetentionHours),",
            "     deletable: true,",
            "     insertable: false,",
            "     updateable: false,",
            "     upsertable: true,",
            "     keys:['partitionName','studyInstanceUid'],",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     saveOrder: 3,",
            "     mapColumn(",
            "          partitionName,",
            "          studyInstanceUid,",
            "          lastModifiedTimestamp,",
            "          studyDate,",
            "          studyDescription,",
            "          issuerOfPatientId,",
            "          patientId,",
            "          patientName,",
            "          seriesCount,",
            "          instanceCount",
            "     ),",
            "     partitionBy('key',",
            "          0,",
            "          partitionName",
            "     )) ~> studyTable",
            "seriesChanges sink(validateSchema: false,",
            "     keys:['partitionName','studyInstanceUid','seriesInstanceUid'],",
            "     store: 'cache',",
            "     format: 'inline',",
            "     output: false,",
            "     saveOrder: 1) ~> seriesCache",
            "studyChanges sink(validateSchema: false,",
            "     keys:['partitionName','studyInstanceUid'],",
            "     store: 'cache',",
            "     format: 'inline',",
            "     output: false,",
            "     saveOrder: 1) ~> studyCache"
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.DataFactory/factories/linkedservices', variables('dataFactoryName'), variables('AzureDataLakeStoragename'))]",
        "[resourceId('Microsoft.DataFactory/factories', variables('dataFactoryName'))]",
        "[resourceId('Microsoft.DataFactory/factories/linkedservices', variables('dataFactoryName'), variables('RestServicename'))]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "scope": "[format('Microsoft.HealthcareApis/workspaces/{0}/dicomservices/{1}', split(variables('dicomservicename'), '/')[0], split(variables('dicomservicename'), '/')[1])]",
      "name": "[guid(resourceId('Microsoft.HealthcareApis/workspaces/dicomservices', split(variables('dicomservicename'), '/')[0], split(variables('dicomservicename'), '/')[1]), variables('principalType'))]",
      "properties": {
        "roleDefinitionId": "[format('/subscriptions/{0}/providers/Microsoft.Authorization/roleDefinitions/58a3b984-7adf-4c20-983a-32417c86fbc8', variables('subscriptionid'))]",
        "principalId": "[reference(format('Microsoft.DataFactory/factories/{0}', variables('dataFactoryName')), '2018-06-01', 'Full').identity.principalId]",
        "principalType": "[variables('principalType')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.HealthcareApis/workspaces/dicomservices', split(variables('dicomservicename'), '/')[0], split(variables('dicomservicename'), '/')[1])]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "scope": "[format('Microsoft.HealthcareApis/workspaces/{0}/dicomservices/{1}', split(variables('dicomservicename'), '/')[0], split(variables('dicomservicename'), '/')[1])]",
      "name": "[guid(resourceId('Microsoft.HealthcareApis/workspaces/dicomservices', split(variables('dicomservicename'), '/')[0], split(variables('dicomservicename'), '/')[1]), variables('principalType'), 'reader')]",
      "properties": {
        "roleDefinitionId": "[format('/subscriptions/{0}/providers/Microsoft.Authorization/roleDefinitions/e89c7a3c-2f64-4fa1-a847-3e4c9ba4283a', variables('subscriptionid'))]",
        "principalId": "[reference(format('Microsoft.DataFactory/factories/{0}', variables('dataFactoryName')), '2018-06-01', 'Full').identity.principalId]",
        "principalType": "[variables('principalType')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.HealthcareApis/workspaces/dicomservices', split(variables('dicomservicename'), '/')[0], split(variables('dicomservicename'), '/')[1])]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2020-04-01-preview",
      "scope": "[format('Microsoft.Storage/storageAccounts/{0}', variables('storageAccountName'))]",
      "name": "[guid(variables('storageAccountName'), variables('dataFactoryName'), variables('principalType'))]",
      "properties": {
        "roleDefinitionId": "[variables('storageBlobDataContributorRole')]",
        "principalId": "[reference(format('Microsoft.DataFactory/factories/{0}', variables('dataFactoryName')), '2018-06-01', 'Full').identity.principalId]",
        "principalType": "[variables('principalType')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2020-04-01-preview",
      "scope": "[format('Microsoft.Storage/storageAccounts/{0}', variables('storageAccountName'))]",
      "name": "[guid(variables('storageAccountName'), variables('managedIdentityName'))]",
      "properties": {
        "roleDefinitionId": "[variables('storageBlobDataContributorRole')]",
        "principalId": "[reference(format('Microsoft.ManagedIdentity/userAssignedIdentities/{0}', variables('managedIdentityName')), '2023-01-31').principalId]",
        "principalType": "[variables('principalType')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2020-04-01-preview",
      "scope": "[format('Microsoft.Storage/storageAccounts/{0}', variables('storageAccountName'))]",
      "name": "[guid('queueassignment',subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '974c5e8b-45b9-4653-ba55-5f855dd0fb88'))]",
      "properties": {
        "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '974c5e8b-45b9-4653-ba55-5f855dd0fb88')]",
        "principalId": "[reference(resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName')), '2021-03-01', 'full').identity.principalId]",
        "description": "Assign queue data contributor role to App"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Web/sites', variables('storageQueueProcessingAppName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    }
  ]
}